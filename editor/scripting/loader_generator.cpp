#include "chokoeditor.hpp"
#include "chokoplayer.hpp"

CE_BEGIN_ED_NAMESPACE

void EScriptLoaderGen::Generate() {
	const auto& ents = EAssetList::scriptEntries();

	IO::RemoveDirectory(CE_DIR_SYSTEM + "src/loaders/");
	IO::MakeDirectory(CE_DIR_SYSTEM + "src/loaders/");
	
	std::ofstream cmake(CE_DIR_SYSTEM + "src/loaders.cmake");

	cmake << R"(# Generated by ChokoEditor. DO NOT EDIT.

target_sources(chokoeditor_project PRIVATE
)";
	for (auto& e : ents) {
		cmake << "	${CMAKE_SOURCE_DIR}/system/src/loaders/load_"
			+ e.info->className + ".cpp\n";
	}

	cmake << ")";

	std::ofstream base(CE_DIR_SYSTEM + "src/loader_base.cpp");

	base << R"(
/*
 * Generated by ChokoEditor.
 * DO NOT EDIT.
 */
#include "loader_base.hpp"

CE_BEGIN_PL_NAMESPACE

ScriptLoaderImpl _ScriptLoaderImpl::getld(const std::string& s) {
	auto& res = _lds[s];
	if (!res) {
		if (0) {}
)";
	for (auto& e : ents) {
		base << 
"			else if (s == \"" + e.sig + "\"){\n\
				res = std::make_shared<_ScrLdImpl_" + e.info->className + ">();\n\
			}";
	}

	base << R"(
		}
		return res;
	}

CE_END_PL_NAMESPACE	
)";

	base.close();
	base.open(CE_DIR_SYSTEM + "src/loader_base.hpp");

	base << R"(
/*
 * Generated by ChokoEditor.
 * DO NOT EDIT.
 */
#pragma once
#include "chokoplayer.hpp"

CE_BEGIN_PL_NAMESPACE

)";

	for (auto& e : ents) {
		base << "CE_PL_OBJ(ScrLdImpl_" + e.info->className + ")\n";
	}

	base << R"(
CE_PL_OBJ(ScriptLoaderImpl)
class _ScriptLoaderImpl : public _ScriptLoaderBase {
protected:
	const std::string _sig;
	const std::vector<ScriptVarEntry> _entries;
	Component tar;
	std::unordered_map<std::string, ScriptLoaderImpl> _lds;

	ScriptLoaderImpl getld(const std::string& s);

	_ScriptLoaderImpl(const std::string& s, const std::vector<ScriptVarEntry>& e)
		: _sig(s), _entries(e) {}
public:
	static void Init() {
		instance = std::make_shared<_ScriptLoaderImpl>();
	}
	_ScriptLoaderImpl() : _sig(""), _entries({}), tar(nullptr), _lds({}) {}
	CE_PL_NS ScriptLoaderBase GetLoaderOf(const std::string& s) override {
		return getld(s);
	}
	std::string sig() override {
		return _sig;
	}
	Component Instantiate() override { abort(); }
	void activeTarget(const Component& t) override {
		tar = t;
	}
	std::vector<ScriptVarEntry> GetVarsOf(const std::string& s) override {
		return getld(s)->_entries;
	}
#define _IMPL_GETSET(tp)\
    void set_ ## tp(const std::string&, const tp&) override { abort(); }\
    tp get_ ## tp(const std::string&) override { abort(); };

    _IMPL_GETSET(int)
    _IMPL_GETSET(float)
    _IMPL_GETSET(Vec2)
    _IMPL_GETSET(Vec3)
    _IMPL_GETSET(Vec4)
    _IMPL_GETSET(Quat)
    _IMPL_GETSET(Asset)
#undef _IMPL_GETSET
};

CE_END_PL_NAMESPACE

)";

	for (auto& e : ents) {
		const auto& nm = e.info->className;
		const auto& vars = e.info->vars;

		const auto file = "loaders/load_" + nm;

		base << "#include \"" + file + ".hpp\"\n";

		std::ofstream impl(CE_DIR_SYSTEM + "src/" + file + ".hpp");

		const auto classnm = "_ScrLdImpl_" + nm;
		const auto classcc = classnm + "::";

		impl << R"(
/*
 * Generated by ChokoEditor.
 * DO NOT EDIT.
 */
#pragma once
#include "chokoplayer.hpp"
#include "../loader_base.hpp"
#include ")" + e.sig + R"("

CE_BEGIN_PL_NAMESPACE

class )" + classnm + R"( : public _ScriptLoaderImpl {
public:
	)" + classnm + R"(();

	Component Instantiate() override;
	
	CE_PL_SCR_GETSET_DEFS
};

CE_END_PL_NAMESPACE
)";

		impl.close();
		impl.open(CE_DIR_SYSTEM + "src/" + file + ".cpp");

		impl << R"(
/*
 * Generated by ChokoEditor.
 * DO NOT EDIT.
 */
#include "./load_)" + nm + R"(.hpp"

CE_BEGIN_PL_NAMESPACE

)" + classcc + classnm + R"(() : _ScriptLoaderImpl(")" + e.sig + R"(", {
)";

	static const std::string tpss[] = {
		"int",
        "float",
        "Vec2",
        "Vec3",
        "Vec4",
        "Quat"
	};
	static const auto tpsn = sizeof(tpss) / sizeof(tpss[0]);
	static const std::string tpss2[] = {
		"Asset"
	};
	static const auto tpsn2 = sizeof(tpss2) / sizeof(tpss2[0]);

	for (auto& v : vars) {
		impl << "\
	ScriptVarEntry(\"" + v.name + "\", (ScriptVarEntry::Type)"
			+ std::to_string((int)v.type) + ", \"" + v.sub_class + "\")"
			+ ((&v == &vars.back()) ? "\n" : ",\n");
	}

	impl << R"(}) {}

Component )" + classcc + R"(Instantiate() {
	return tar = )" + nm + R"(::New();
}
	
)";

	for (int a = 0; a < tpsn; a++) {
		const auto& tps = tpss[a];
		impl << tps + " " + classcc + "get_" + tps + "(const std::string& s) {\n\
	auto scr = " + nm + "(tar);\n\
	if (0) {}\n";
		for (auto& v : vars) {
			if ((int)v.type == a) {
				impl << "	else if (s == \"" + v.name + "\") { return scr->"
					+ v.name + "; }\n";
			}
		}
		impl << "	else abort();\n\
}\n\
void " + classcc + "set_" + tps + "(const std::string& s, const " + tps + "& v) {\n\
	auto scr = " + nm + "(tar);\n\
	if (0) {}\n";
		for (auto& v : vars) {
			if ((int)v.type == a) {
				impl << "	else if (s == \"" + v.name + "\") { scr->"
					+ v.name + " = v; }\n";
			}
		}
		impl << "	else abort();\n\
}\n\
";
	}

	for (int a = 0; a < tpsn2; a++) {
		const auto& tps = tpss2[a];
		impl << tps + " " + classcc + "get_" + tps + "(const std::string& s) {\n\
	auto scr = " + nm + "(tar);\n\
	if (0) {}\n";
		for (auto& v : vars) {
			if ((int)v.type == tpsn + a) {
				impl << "	else if (s == \"" + v.name + "\") { return scr->"
					+ v.name + "; }\n";
			}
		}
		impl << "	else abort();\n}\n\
void " + classcc + "set_" + tps + "(const std::string& s, const " + tps + "& v) {\n\
	auto scr = " + nm + "(tar);\n\
	if (0) {}\n";
		for (auto& v : vars) {
			if ((int)v.type == tpsn + a) {
				impl << "	else if (s == \"" + v.name + "\") { scr->"
					+ v.name + " = (decltype(scr->" + v.name + "))v; }\n";
			}
		}
		impl << "	else abort();\n}\n";
	}

	impl << R"(

CE_END_PL_NAMESPACE
)";
	}
}

CE_END_ED_NAMESPACE
