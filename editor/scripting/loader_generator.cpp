#include "chokoeditor.hpp"
#include "chokoplayer.hpp"

CE_BEGIN_ED_NAMESPACE

void EScriptLoaderGen::Generate() {
	const auto& ents = EAssetList::scriptEntries();

	IO::RemoveDirectory(CE_DIR_SYSTEM + "src/loaders/");
	IO::MakeDirectory(CE_DIR_SYSTEM + "src/loaders/");
	
	std::ofstream cmake(CE_DIR_SYSTEM + "src/loaders.cmake");

	cmake << R"(# Generated by ChokoEditor. DO NOT EDIT.

target_sources(chokoeditor_project PRIVATE
)";
	for (auto& e : ents) {
		cmake << "	${CMAKE_SOURCE_DIR}/system/src/loaders/load_"
			+ e.info->className + ".cpp\n";
	}

	cmake << ")";

	std::ofstream base(CE_DIR_SYSTEM + "src/loader_base.cpp");

	base << R"(
/*
 * Generated by ChokoEditor.
 * DO NOT EDIT.
 */
#include "loader_base.hpp"

CE_BEGIN_PL_NAMESPACE

ScriptLoaderBase _ScriptLoaderImpl::GetLoaderOf(const std::string& s) {
	if (!(instance = _lds[s])) {
		if (0) {}
)";
	for (auto& e : ents) {
		base << 
"		else if (s == \"" + e.sig + "\"){\n\
			instance = std::make_shared<_ScrLdImpl_" + e.info->className + ">();\n\
		}";
	}

base << R"(
	}
	return instance;
}

std::vector<ScriptVarEntry> _ScriptLoaderImpl::GetVarsOf(const std::string& s) {
	//do we even call this in runtime?
	Debug::Error("ScriptLoader", "GetVarsOf called (not implemented)!");
	return {};
}

CE_END_PL_NAMESPACE	
)";

	base.close();
	base.open(CE_DIR_SYSTEM + "src/loader_base.hpp");

	base << R"(
/*
 * Generated by ChokoEditor.
 * DO NOT EDIT.
 */
#pragma once
#include "chokoplayer.hpp"

CE_BEGIN_PL_NAMESPACE

)";

	for (auto& e : ents) {
		base << "CE_PL_OBJ(ScrLdImpl_" + e.info->className + ")\n";
	}

	base << R"(
CE_PL_OBJ(ScriptLoaderImpl)
class _ScriptLoaderImpl : public _ScriptLoaderBase {
protected:
	const std::string _sig;
	const std::vector<ScriptVarEntry> _entries;
	Component tar;
	std::unordered_map<std::string, ScriptLoaderImpl> _lds;

	_ScriptLoaderImpl(const std::string& s, const std::vector<ScriptVarEntry>& e)
		: _sig(s), _entries(e) {}
public:
	static void Init() {
		instance = std::make_shared<_ScriptLoaderImpl>();
	}
	_ScriptLoaderImpl() : _sig(""), _entries({}), tar(nullptr), _lds({}) {}

	virtual ~_ScriptLoaderImpl() = default;

	ScriptLoaderBase GetLoaderOf(const std::string& s) override;
	std::string sig() override {
		return _sig;
	}
	Component Instantiate() override { abort(); }
	void activeTarget(const Component& t) override {
		tar = t;
	}
	std::vector<ScriptVarEntry> GetVarsOf(const std::string& s) override;

#define _IMPL_GETSET(tp)\
    void set_ ## tp(const std::string&, const tp&) override { std::cout << "NO" << std::endl; abort(); }\
    tp get_ ## tp(const std::string&) override { std::cout << "NO" << std::endl; abort(); };

	void set_vecsize(const std::string&, const size_t) override { std::cout << "NO" << std::endl; abort(); }
	size_t get_vecsize(const std::string&) override { std::cout << "NO" << std::endl; abort(); }
    _IMPL_GETSET(int)
    _IMPL_GETSET(float)
    _IMPL_GETSET(Vec2)
    _IMPL_GETSET(Vec3)
    _IMPL_GETSET(Vec4)
    _IMPL_GETSET(Quat)
    _IMPL_GETSET(Asset)
    _IMPL_GETSET(SceneObject)
#undef _IMPL_GETSET
};

#define _CE_MEMACC_S(nm)\
if (i != -1) abort();\
else return &c->nm;

#define _CE_MEMACC_A(nm)\
if (i == -1) abort();\
else return &c->nm[i];

#define _CE_GETMEM_C(nm, cl, fn)\
else if (s == #nm) {\
    if (tsz < size_t(-2)) {\
        c->nm.resize(tsz);\
        return nullptr;\
    }\
    else if (tsz == size_t(-2)) {\
        return (void*)c->nm.size();\
    }\
    else {\
        nextclass = #cl;\
        fn\
    }\
}

#define _CE_GETMEM_I(nm, fn)\
else if (s == #nm) {\
    if (tsz != size_t(-1)) {\
        abort();\
    }\
    else {\
        nextclass = "-";\
        fn\
    }\
}

#define _CE_GETMEMFNARGS void* cl, const std::string& s, int i, size_t tsz, std::string& nextclass
typedef void* (*_scrimpl_getmemFn)(_CE_GETMEMFNARGS);

template <typename T>
T& _scrimpl_getslot(const std::string& sig, void* ptr, const std::unordered_map<std::string, _scrimpl_getmemFn>& fns) {
    auto ss = StrExt::Split(sig, '.');
    
    std::string nextclass = "";
    for (auto& s : ss) {
        const auto arrc = s.find('!');
        int arri = -1;
        if (arrc != std::string::npos) {
            arri = std::stoi(s.substr(0, arrc));
            s = s.substr(arrc + 1);
        }
        ptr = fns.at(nextclass)(ptr, s, arri, size_t(-1), nextclass);
    }
    return *(T*)ptr;
}

CE_END_PL_NAMESPACE

)";

	for (auto& e : ents) {
		const auto& nm = e.info->className;
		const auto& vars = e.info->vars;
		const auto& classes = e.info->classes;

		const auto file = "loaders/load_" + nm;

		base << "#include \"" + file + ".hpp\"\n";

		std::ofstream impl(CE_DIR_SYSTEM + "src/" + file + ".hpp");

		const auto classnm = "_ScrLdImpl_" + nm;
		const auto classcc = classnm + "::";

		impl << StrExt::ReplaceAll(R"(
/*
 * Generated by ChokoEditor.
 * DO NOT EDIT.
 */
#pragma once
#include "chokoplayer.hpp"
#include "../loader_base.hpp"
#include "SCRPATHREPL"

CE_BEGIN_PL_NAMESPACE

class IMPLCLASSREPL : public _ScriptLoaderImpl {
public:
	IMPLCLASSREPL();

	Component Instantiate() override;
	
	CE_PL_SCR_GETSET_DEFS
};

CE_END_PL_NAMESPACE
)", {
			{ "SCRPATHREPL", e.sig },
			{ "IMPLCLASSREPL", classnm }
		});

		impl.close();
		impl.open(CE_DIR_SYSTEM + "src/" + file + ".cpp");

		impl << R"(
/*
 * Generated by ChokoEditor.
 * DO NOT EDIT.
 */
#include "./load_)" + nm + R"(.hpp"

CE_BEGIN_PL_NAMESPACE

)" + classcc + classnm + R"(() : _ScriptLoaderImpl(")" + e.sig + R"(", {
)";

		for (auto& v : vars) {
			impl << "        ScriptVarEntry(\"" + v.name + "\", (ScriptVarEntry::Type)"
				+ std::to_string((int)v.type) + ", \"" + v.sub_class + "\")"
				+ ((&v == &vars.back()) ? "\n" : ",\n");
		}

		impl << R"(    }) {}

namespace {
    void* getmember_this(_CE_GETMEMFNARGS) {
        auto c = (_)" + nm + "*)cl;\n        if (0) { abort(); }\n";

		for (auto& v : vars) {
			const auto getstr = std::string(", _CE_MEMACC_") + (v.is_vector ? "A(" : "S(") + v.name + "))\n";
			if (v.type == ScriptVar::Type::Class) {
				impl << "        _CE_GETMEM_C(" + v.name + ", " + v.sub_class + getstr;
			}
			else {
				impl << "        _CE_GETMEM_I(" + v.name + getstr;
			}
		}
		impl << "        else abort();\n    }\n";

		for (auto& c : classes) {
			impl << "    void* getmember_" + c.name + "(_CE_GETMEMFNARGS) {\n"
"        auto c = (_" + nm + "::" + c.name + "*)cl;\n        if (0) { abort(); }\n";

			for (auto& v : c.vars) {
				const auto getstr = std::string(", _CE_MEMACC_") + (v.is_vector ? "A(" : "S(") + v.name + "))\n";
				if (v.type == ScriptVar::Type::Class) {
					impl << "        _CE_GETMEM_C(" + v.name + ", " + v.sub_class + getstr;
				}
				else {
					impl << "        _CE_GETMEM_I(" + v.name + getstr;
				}
			}
			impl << "        else abort();\n    }\n";
		}

		impl << R"(
    const std::unordered_map<std::string, _scrimpl_getmemFn> _fnMap = {
        {"", getmember_this})";
		for (auto& c : classes) {
			impl << ",\n        {\"" + c.name + "\", getmember_" + c.name + "}";
		}
		impl << StrExt::ReplaceAll(R"(
    };
    
    template <typename T>
    T& getslot(const std::string& s, _Component* tar) {
        return _scrimpl_getslot<T>(s, (_CLASSNAMEREPL*)tar, _fnMap);
    }
}

Component IMPLCLASSREPL::Instantiate() {
    return tar = CLASSNAMEREPL::New();
}

void IMPLCLASSREPL::set_vecsize(const std::string& sig, const size_t n) {
    auto ss = StrExt::Split(sig, '.');
    
    void* ptr = ((CLASSNAMEREPL)tar).operator->();
    std::string nextclass = "";
    for (auto& s : ss) {
        const auto arrc = s.find('!');
        int arri = -1;
        if (arrc != std::string::npos) {
            arri = std::stoi(s.substr(0, arrc));
            s = s.substr(arrc + 1);
        }
        ptr = _fnMap.at(nextclass)(ptr, s, arri, (&s == &ss.back())? n : size_t(-1), nextclass);
    }
}
size_t IMPLCLASSREPL::get_vecsize(const std::string& sig) {
    auto ss = StrExt::Split(sig, '.');
    
    void* ptr = ((CLASSNAMEREPL)tar).operator->();
    std::string nextclass = "";
    for (auto& s : ss) {
        const auto arrc = s.find('!');
        int arri = -1;
        if (arrc != std::string::npos) {
            arri = std::stoi(s.substr(0, arrc));
            s = s.substr(arrc + 1);
        }
        ptr = _fnMap.at(nextclass)(ptr, s, arri, (&s == &ss.back())? size_t(-2) : size_t(-1), nextclass);
    }
    return (size_t)ptr;
}

#define GETSET(tp)\
tp IMPLCLASSREPL::get_ ## tp(const std::string& s) {\
    return _scrimpl_getslot<tp>(s, tar.operator->(), _fnMap);\
}\
void IMPLCLASSREPL::set_ ## tp(const std::string& s, const tp& v) {\
    _scrimpl_getslot<tp>(s, tar.operator->(), _fnMap) = v;\
}

GETSET(int)
GETSET(float)
GETSET(Vec2)
GETSET(Vec3)
GETSET(Vec4)
GETSET(Quat)
GETSET(SceneObject)
GETSET(Asset)

CE_END_PL_NAMESPACE
)", {
			{ "CLASSNAMEREPL", nm },
			{ "IMPLCLASSREPL", classnm }
		});
	}
}

CE_END_ED_NAMESPACE
