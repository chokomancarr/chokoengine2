import os
import sys

path = sys.argv[1]
path2 = path[:-4] + "_str.hpp"
src_file = open(path, "r")
dst_file = open(path2, "w")

print("generating: " + path2)

first_word = ""
first_inc = ""
ns_def = ""
ns_def_s = "CE_NS "

while first_word != "enum":
    line = src_file.readline().strip()
    lsplit = line.split()
    if len(lsplit) > 1:
        first_word = lsplit[0]
        if first_word == "#include" and not len(first_inc):
            first_inc = line
    elif line[0:8] == "CE_BEGIN":
        ns_def = line[8:]
        if (len(ns_def) > 10):
            ns_def_s = "CE" + ns_def[:-9] + "NS "

enum_name = lsplit[1]
if enum_name == "class":
    enum_name = lsplit[2]
if enum_name[-1] == '{':
    enum_name = enum_name[:-1]

print("  enum: " + enum_name)

dst_file.write(R"""/*
 * Generated by the preprocessor script
 * DO NOT EDIT
 */
#pragma once
""" + first_inc + "\n\n"

+ "namespace std { template <> struct hash<" + ns_def_s + enum_name + "> { size_t operator() (const " + ns_def_s + enum_name + " &t) const { return size_t(t); } }; }"
+ "\n\nCE_BEGIN" + ns_def + "\
\n\nconst std::unordered_map<""" + enum_name + ", std::string> " + enum_name + "Str = {\n")

strs = []

while True:
    line = src_file.readline().strip()
    if not len(line):
        continue
    if line[0:2] == "//":
        continue
    if line[0:2] == "/*" and line[-2:] == "*/":
        continue
    if line[0] == '}':
        break
    lsplit = line.split(",")
    for l in lsplit:
        l = l.strip()
        if not len(l):
            continue
        if l[0:2] == "//":
            continue
        if l[0:2] == "/*" and l[-2:] == "*/":
            continue
        l = l.split('=')[0].strip()
        strs.append("{ " + enum_name + "::" + l + ", \"" + l + "\" }")

for s in strs[:-1]:
    dst_file.write("\t" + s + ",\n")
dst_file.write("\t" + strs[-1])

dst_file.write(R"""
};

CE_END""" + ns_def + "\n")
